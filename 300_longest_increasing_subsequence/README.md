## 解题思路

### 动态规划

定义 dp[i] 为前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度

在最坏的情况,也就是数组以降序排列时，`dp = [1] * n` ，n为num数组长度。

要计算dp[1]，我们只需要判断num[0]是否小于num[1]，如果是`dp[1] = dp[0] + 1 = 2`，如果不是dp[1]保持不变`dp[1] = 1`

要计算dp[2]，我们要判断num[0]和num[1]是否小于num[2]。
    
* 假如num[0]小于num[2]，此时`dp[2] = dp[0] + 1`
    * 假如num[1]也小于num[2]，此时`dp[2] = max(dp[1] + 1, dp[2])`
    * 假如num[1]大于num[2]，此时num1和num2无法组成上升子序列，不处理`dp[2] = dp[2]`
    
* 假如num[0]大于num[2]，此时num[0]和num[2]无法组成上升子序列，不处理`dp[2] = dp[2]`
    * 假如num[1]小于num[2]，此时`dp[2] = dp[1] + 1`
    * 假如num[1]大于num[2]，此时num1和num2无法组成上升子序列，不处理`dp[2] = dp[2]`

观察上面的逻辑，我们可以得出dp[i]和dp[i-1]的状态转移关系：

$$dp[i] = max(dp[i], dp[j] + 1)， 其中0<= j< i且num[j] < num[i]$$

最终dp数组的最大值就是数组的最长上升子序列 时间复杂度O(n<sup>2</sup>) 空间复杂度O(n)